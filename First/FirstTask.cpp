#include "stdafx.h"
#include "FirstTask.h"

/*
С помощью списка инициализации, даём значения для полей класса.
Координаты каждый раз будут отличаться с посредством функции rand().
Здесь же расчитываем, находится ли целевая точка в радиусе эффективного действмя манипуляторов.
*/
FirstTask::FirstTask() : O1{ int(-10 + rand() % 20), int(-10 + rand() % 20) }, O2{ int(-10 + rand() % 20) , int(-10 + rand() % 20) },
	P1{ int(-10 + rand() % 20) , int(-10 + rand() % 20) }, R1(1 + rand() % 5), R2(1 + rand() % 5),
	O1InRange((pow(P1[0] - O1[0], 2) + pow(P1[1] - O1[1], 2)) <= pow(R1, 2)), O2InRange((pow(P1[0] - O2[0], 2) + pow(P1[1] - O2[1], 2)) <= pow(R2, 2))
{

}


/*
Для вывода данных испоьзуем стандартный выходной поток std::cout
*/
void FirstTask::showData()
{
	std::cout << "O1: ";

	for (int i : O1)
	{
		std::cout << i << ";";
	}

	std::cout << std::endl << "O2: ";

	for (int i : O2)
	{
		std::cout << i << ";";
	}

	std::cout << std::endl << std::endl << "R1: " << R1 << std::endl;

	std::cout << "R2: " << R2 << std::endl;


	std::cout << std::endl << "P1: ";

	for (int i : P1)
	{
		std::cout << i << ";";
	}
}


/*
Для того, чтобы вычислить находится ли целевая точка в радиусе эффективного действия манипуляторов используется формула
(x - a)^2 + (y - b)^2 <= R^2, где x и y координаты целевой точки, a и b координаты манипулятора, а R - длина радиуса эффективного действия манипулятора
если радиус эффективного действия больше или равен (x - a)^2 + (y - b)^2, то манипулятор может достать до целевой точки.
*/
void FirstTask::showCalculations()
{
	std::cout << "(x - a)^2 + (y - b)^2 <= R^2" << std::endl;
	std::cout << "(" << P1[0] << " - (" << O1[0] << "))^2 + (" << P1[1] << " - (" << O1[1] << "))^2 <= " << pow(R1, 2) << std::endl;
	std::cout << pow(P1[0] - O1[0], 2) + pow(P1[1] - O1[1], 2) << " <= " << pow(R1, 2) << std::endl;

	std::cout << std::endl << "(x - a)^2 + (y - b)^2 = R^2" << std::endl;
	std::cout << "(" << P1[0] << " - " << O2[0] << "))^2 + (" << P1[1] << " - (" << O2[1] << "))^2 <= " << pow(R2, 2) << std::endl;
	std::cout << pow(P1[0] - O2[0], 2) + pow(P1[1] - O2[1], 2) << " <= " << pow(R2, 2) << std::endl << std::endl;
}


/*
Для расчёта расстояния от первого манипулятора до целевой точки испльзуется формула
√(x - a)^2 + (y - b)^2 - где x и y координаты целевой точки, a и b координаты манипулятора, а R - длина радиуса эффективного действия манипулятора
*/
float FirstTask::calculateDistanceToPointO1()
{
	return float(sqrt(pow(P1[0] - O1[0], 2) + pow(P1[1] - O1[1], 2)));
}

/*
Для расчёта расстояния от второго манипулятора до целевой точки испльзуется формула
√(x - a)^2 + (y - b)^2 - где x и y координаты целевой точки, a и b координаты манипулятора, а R - длина радиуса эффективного действия манипулятора
*/
float FirstTask::calculateDistanceToPointO2()
{
	return float(sqrt(pow(P1[0] - O2[0], 2) + pow(P1[1] - O2[1], 2)));
}


/*
возвращает булевое значение, которое показывает находится ли целевая точка в радиусе эффективного действия первого манипулятора
*/
bool FirstTask::isO1InOfRange()
{
	return O1InRange;
}


/*
возвращает булевое значение, которое показывает находится ли целевая точка в радиусе эффективного действия второго манипулятора
*/
bool FirstTask::isO2InOfRange()
{
	return O2InRange;
}
